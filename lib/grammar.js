import{w as e}from"./utils-be932c53.js";import t,{gsub as r,regExpToString as n}from"./template.js";import s from"./context.js";import"./utils/verbose-regexp.js";class i extends Error{constructor(e){super(e),this.name="ParseError"}}class a{constructor(e,t,r={}){"object"!=typeof e||t?(this.name=e,this.names=[e,...r.alias||[]],this._classNamePattern=new RegExp("\\b(?:"+this.names.join("|")+")\\b")):(this.name=null,r=t||r,t=e),this.options=r,this.rules=[],this._originalRules=t,this.extend(t),this.name&&this.names.forEach((e=>{a.register(e,this)}))}_toObject(){return{...this._originalRules}}parse(t,n=null){let l=this.pattern;return l.lastIndex=0,n||(n=new s({highlighter:{parse:e=>e}})),l.test(t)?r(t,l,((t,r)=>{let s,h,o,c=0,u=1;for(;s=this.rules[c++];){if(!t[u]){u+=s.length;continue}if(s.index&&(o=s.index(t[0],n),o<=0&&(o=void 0),void 0!==o&&(h=o+1,r=r.slice(0,t.index+h),!(t=l.exec(r))||!t[u]))){let e=new i('Bad "index" callback; requested substring did not match original rule.');throw Object.assign(e,{rule:s,source:r,match:t,index:o}),e}let c=[];for(let e=0;e<=s.length;e++)c.push(t[u+e]);if(c.name=s.name,s.captures)for(let t=0;t<c.length;t++){if(!(t in s.captures))continue;let r="function"==typeof(p=s.captures[t])?p():p;"string"==typeof r?c[t]=e(c[t],r):r instanceof a&&c[t]&&(c[t]=r.parse(c[t],n))}if(s.before){let e=s.before(c,n);void 0!==e&&(c=e)}let m=s.replacement;c.name||(c.name=s.name),c.index=t.index;let f=m.evaluate(c);if(s.after){let e=s.after(f,n);void 0!==e&&(f=e)}return void 0!==o?[f,h]:f}var p;return""})):t}_makeRules(e,t=0){let r=[];for(let[n,s]of Object.entries(e)){let e=s.name||n,i=new h(e,s,t);r.push(i),t+=i.length}return r}match(e){return this._classNamePattern.test(e)}extend(...e){let t;if(1!==e.length)return e.forEach((e=>this.extend(e))),this;if(t=e[0],t instanceof a&&(t=t.toObject()),!t)throw new Error("Nonexistent grammar!");let r=0;this.rules.length&&(r=this.rules.map((e=>e.length)).reduce(((e,t)=>e+t)));let n=t,s=this._makeRules(n,r);return this.rules.push(...s),this.pattern=new RegExp(this.rules.map((e=>e.pattern)).join("|"),this.options.ignoreCase?"mi":"m"),this}toObject(){let e={};return this.rules.forEach((t=>{e[t.name]=t.toObject()})),e}}const l={};a.register=(e,t)=>{l[e]=t},a.find=e=>l[e]||null;class h{constructor(e,r,s){this.name=e;let i=r.replacement;i?this.replacement=i instanceof t?i:new t(i):r.captures?this.replacement=null:this.replacement=h.DEFAULT_TEMPLATE,this.debug=r.debug,this.before=r.before,this.after=r.after,this.index=r.index,this.captures=r.captures;let a=r.pattern,l=r.pattern;"string"!=typeof l&&(l=n(l)),l=l.replace(/\\(\d+)/g,((e,t)=>{let r=Number(t);return`\\${s+r+1}`}));let o=(l.match(/\(/g)||"").length,c=(l.match(/\(\?[:!=]/g)||"").length+(l.match(/\\\(/g)||"").length-(l.match(/\\\(\?[:!=]/g)||"").length;this.length=o+1-c,this.pattern=`(${l})`,this.originalPattern=a,this.replacement||(this.replacement=h.makeReplacement(this.length,r.wrapReplacement))}toObject(){return{pattern:this.originalPattern,replacement:this.replacement,before:this.before,after:this.after,index:this.index,captures:this.captures}}}h.DEFAULT_TEMPLATE=new t('<span class="#{name}">#{0}</span>'),h.makeReplacement=(e,r)=>{let n=[];for(let t=1;t<e;t++)n.push(t);let s=n.join("}#{");return s=`#{${s}}`,new t(r?`<span class="#{name}">${s}</span>`:s)};export{h as Rule,a as default};
