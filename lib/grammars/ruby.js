import e from"../grammar.js";import{b as t,c as a,w as n}from"../utils-be932c53.js";import{VerboseRegExp as r}from"../utils/verbose-regexp.js";import"../template.js";import"../context.js";function s(e,t){return e.indexOf(t)>-1}function p(e,a){let n=e.slice(a).join(""),r=t(n,"}","{",{stackDepth:1});if(-1===r)return;let s=0;for(let t=a;t<e.length;t++)if(s+=e[t].length,s>=r)return t}function c(e,t,a){let n=[];for(let r=t;r<=a;r++)n.push(e[r]);return n.join(",")}function l(e,t,a){t||(t=o);let n=e.split(/,/),r=[];for(let e,t=0;t<n.length;t++)if(e=n[t],s(l=e,"{")&&!s(l,"}")){let e=p(n,t+1),a=c(n,t,e);r.push(a),t=e}else r.push(e);var l;return r.map((e=>t.parse(e,a)))}const o=new e({"meta: parameter with default":{pattern:/^(\s*)([A-Za-z0-9_]+)(\s*=\s*)(.*)/,captures:{2:"variable variable-parameter",3:"keyword operator",4:()=>d}},"meta: variable":{pattern:/^(\s*)([A-Za-z0-9_]+)$/,captures:{2:"variable variable-parameter"}}}),i=new e({"meta: block variable":{pattern:/^(\s*)([A-Za-z0-9_]+)$/,captures:{2:"variable variable-parameter"}}}),d=new e({"named constant":{pattern:/\b([A-Z][A-Z0-9_]*)\b/,captures:{1:"constant"}},"string string-single-quoted":{pattern:/(')([^']*?)(')/},"string string-double-quoted":{pattern:/(")(.*?[^\\])(")/,wrapReplacement:!0,captures:{2:()=>b}},"string string-double-quoted empty":{pattern:/\"\"/},"string string-percent-q string-percent-q-braces":{pattern:/(%Q\{)([\s\S]*)(\})/,index:e=>t(e,"}","{",{startIndex:e.indexOf("{")}),wrapReplacement:!0,captures:{2:()=>b}},"string string-percent-q string-percent-q-parens":{pattern:/(%Q\()([\s\S]*)(\))/,index:e=>t(e,")","(",{startIndex:e.indexOf("(")}),wrapReplacement:!0,captures:{2:()=>b}},"string string-percent-q string-percent-q-brackets":{pattern:/(%Q\[)([\s\S]*)(\])/,index:e=>t(e,"]","[",{startIndex:e.indexOf("[")}),wrapReplacement:!0,captures:{2:()=>b}},"string embedded string-shell-command":{pattern:/(`)([^`]*?)(`)/,wrapReplacement:!0,captures:{2:()=>b}},constant:{pattern:/\b(self|true|false|nil(?!\?))\b/},"number binary":{pattern:/\b0b[01](?:_[01]|[01])*\b/},number:{pattern:/\b(\d(?:[_.]\d|\d)*)\b/},"punctuation punctuation-namespace":{pattern:/(::)/},symbol:{pattern:/:[A-Za-z0-9_!?]+/},"symbol single-quoted":{pattern:/:'([^']*?)'/},"symbol double-quoted":{pattern:/(:)(")(.*?[^\\])(")/,wrapReplacement:!0,captures:{3:()=>b}},regexp:{pattern:/(\/)(.*?)(\/)/,wrapReplacement:!0,captures:{2:()=>u}},"variable variable-instance":{pattern:/(@)[a-zA-Z_][\w\d]*/},"variable variable-global":{pattern:/(\$)[a-zA-Z_][\w\d]*/},keyword:{pattern:/\b(begin|do|class|def|if|module|yield|then|else|for|until|unless|while|elsif|case|when|break|retry|redo|rescue|return|require|lambda)\b/}}),u=new e({escape:{pattern:/\\./},"meta: exclude from group begin":{pattern:/\\\(/,replacement:"#{0}"},"group-begin":{pattern:/(\()/,replacement:'<b class="group">#{1}'},"group-end":{pattern:/(\))/,replacement:"#{1}</b>"}}),b=new e({escape:{pattern:/\\./},interpolation:{pattern:/(#\{)(.*?)(\})/,captures:{1:"punctuation",2:()=>m,3:"punctuation"},wrapReplacement:!0}}),m=new e("ruby",{"meta: method definition":{pattern:/(def)(\s+)([A-Za-z0-9_!?.]+)(?:\s*(\()(.*?)(\)))?/,captures:{1:"keyword",3:"entity"},before:(e,t)=>{e[5]&&(e[5]=l(e[5],null,t))}},"block block-braces":{pattern:r`
      (\{)     # 1: opening brace
      (\s*)    # 2: space
      (\|)     # 3: begin parameters
      ([^|]*?) # 4: contents of parameters
      (\|)     # 5: end parameters
    `,replacement:a("\n      <b class='#{name}'>\n        <span class='punctuation'>#{1}</span>#{2}\n        <span class='punctuation'>#{3}</span>\n        #{4}\n        <span class='punctuation'>#{5}</span>\n    "),before:(e,t)=>{t.get("bracesStack",[]).push(e.name),e[4]=l(e[4],i,t)}},"block block-do-end":{pattern:r`
      (do)         # 1: keyword
      (\s*)        # 2: space
      (\|)         # 3: begin parameters
      ([^|]*?)     # 4: parameters
      (\|)         # 5: end parameters
    `,replacement:a("\n      <b class='#{name}'>\n        <span class='keyword keyword-do'>#{1}</span>#{2}\n        <span class='punctuation'>#{3}</span>\n        #{4}\n        <span class='punctuation'>#{5}</span>\n    "),before:(e,t)=>{t.get("bracesStack",[]).push(e.name),e[4]=l(e[4],null,t),e[6]=m.parse(e[6],t)}},"meta: class definition with superclass":{pattern:r`
      (class)               # 1: keyword
      (\s+)                 # 2: space
      ([A-Z][A-Za-z0-9_]*)  # 3: class name
      (\s*(?:<|&lt;)\s*)    # 4: inheritance symbol, encoded or not
      ([A-Z][A-Za-z0-9:_]*) # 5: superclass
    `,replacement:a("\n      <span class='keyword keyword-class'>#{1}</span>#{2}\n      <span class='entity entity-class'>#{3}</span>\n      <span class='punctuation'>#{4}</span>\n      <span class='entity entity-class entity-superclass'>#{5}</span>\n    ")},"meta: class or module definition":{pattern:r`
      (class|module) # 1: keyword
      (\s+)          # 2: space
      ([A-Z][\w\d]*) # 3: name
      (\s*)          # 4: space
      (?=$|\n)       # lookahead: end of line or end of string
    `,replacement:a("\n      #{1}#{2}#{3}#{4}\n    "),before(e,t){let a=e[1];e[1]=n(e[1],`keyword keyword-${a}`),e[3]=n(e[3],`entity entity-${a}`)}},"string heredoc-indented":{pattern:/(&lt;&lt;-|<<-)([_\w]+?)\b([\s\S]+?)(\2)/,replacement:a("\n      <span class='#{name}'>\n        <span class='heredoc-begin'>#{1}#{2}</span>\n        #{3}\n        <span class='heredoc-end'>#{4}</span>\n      </span>\n    "),captures:{3:()=>b}}});m.extend(d),m.extend({"keyword operator":{pattern:/(\+|-|\*|\/|<<|&lt;&lt;|>|&gt;|<|&lt;|=>|=&gt;|>>|&gt;&gt;|=~|\|\|=|==|=|\|\||&&|\+=|-=|\*=|\/=)/},"keyword keyword-special":{pattern:/\b(initialize|new|loop|extend|raise|attr|catch|throw|private|protected|public|module_function|attr_(?:reader|writer|accessor))\b/},comment:{pattern:/#[^\n]+/},"bracket-block-end":{pattern:/\}/,replacement:"#{0}",after(e,t){let a=t.get("bracesStack",[]).pop();if(a)return`${e} \x3c!-- close ${a} --\x3e</b>`}},"keyword keyword-block-end":{pattern:/\b(end)\b/,after(e,t){let a=t.get("bracesStack",[]).pop();if(a)return`${e} \x3c!-- close ${a} --\x3e</b>`}}});export{m as default};
