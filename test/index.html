<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <link rel="stylesheet" href="./theme.css"   type="text/css">
  <link rel="stylesheet" href="./support.css" type="text/css">

  <script src="../dist/daub.umd.js"></script>
  <script src="./support.js"></script>


  <title>Daub tests</title>

</head>

<body>

<ul>
  <li><a href="#scss">SCSS</a></li>
  <li><a href="#shell">Shell</a></li>
  <li><a href="#ruby">Ruby</a></li>
  <li><a href="#python">Python</a></li>
  <li><a href="#javascript">JavaScript</a></li>
  <li><a href="#html">HTML</a></li>
  <li><a href="#nginx">Nginx</a></li>
</ul>

<pre><code class="javascript">// Find the next "balanced" occurrence of the token. Searches through the
// string unit by unit. Whenever the `paired` token is encountered, the
// stack size increases by 1. When `token` is encountered, the stack size
// decreases by 1, and if the stack size is already 0, that's our desired
// token.
function balance(source, token, paired, options = {}) {
  options = Object.assign(
    { startIndex: 0, stackDepth: 0, considerEscapes: true },
    options
  );

  let lastChar;
  let { startIndex, stackDepth, considerEscapes }
    if (i > 0) { lastChar = source.slice(i - 1, i); }
    let escaped = considerEscapes ? (lastChar === '\\') : false;
    let candidate = source.slice(i, i + tl);
    let pairCandidate = source.slice(i, i + pl);
</code></pre>


<pre><code class="javascript">let escaped = considerEscapes ? (lastChar === '\\') : false;
let escaped = considerEscapes ? (lastChar === '\\') : false;
let escaped = considerEscapes ? (lastChar === '\\') : false;</code></pre>


<pre id="scss" data-lines="1-3, 5"><code class="scss">

@import "post_types/article";
@import "post_types/code";
@import "post_types/conversation";
@import "post_types/image";
@import "post_types/link";
@import "post_types/quotation";
@import "post_types/review";
@import "post_types/thought";
@import "post_types/video";

</code></pre>

<pre id="shell" data-lines="17"><code class="shell">#!/usr/bin/bash

# ARGUMENTS, IN ORDER:
# 1. System (e.g., "arcade")
# 2. Emulator (e.g. "lr-fba-next")
# 3. Full path to game (e.g., /home/pi/RetroPie/roms/arcade/wjammers.zip)

if [ -z "$3" ]; then
  exit 0
fi

# function definition
function _term {
  pkill -P $$
}

trap _term SIGTERM

/usr/bin/avahi-publish -a homebridge.home.local -R 192.168.1.99 &
/usr/bin/avahi-publish -a node-red.home.local -R 192.168.1.99 &
/usr/bin/avahi-publish -a zigbee2mqtt -R 192.168.1.99 &

while true; do sleep 10000; done

system=$1
emulator=$2

# Gets the basename of the game (e.g., "wjammers")
game=`basename $3`
game=$(basename $3)
game=${game%.*}

/home/pi/bin/led-end "$system" "$game" >/dev/null</code></pre>

<pre id="python"><code class="python">#!/usr/bin/env python3

# This is a Python implementation of the script from mausberrycircuits.com.
# It appears to be using a blunt tactic of monitoring the GPIO port (polling
# every second from a bash script). Unless I'm crazy, it's better to use
# interrupts here.
#
# The purpose of this script is to shut down the system gracefully when a
# button is pressed. This, combined with the Mausberry Circuits add-on switch,
# allows for safe startup and shutdown of the Raspberry Pi with the push of a
# button. It runs as a daemon on startup.

import os
import signal
import sys

from RPi import GPIO

# The lead marked OUT.
PIN_OUT = 23
# The lead marked IN.
PIN_IN  = 24

def on_exit(signum, stack):
  GPIO.cleanup()
  sys.exit(1)

signal.signal(signal.SIGINT, on_exit)

GPIO.setmode(GPIO.BCM)

# The lead labeled OUT is setup as IN — it's output from the power switch,
# but it's input to us, and vice-versa.
GPIO.setup(PIN_OUT, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(PIN_IN, GPIO.OUT)

GPIO.output(PIN_IN, GPIO.HIGH)

# The script will wait here until the shutdown event gets flagged by the
# callback thread. That way we don't waste CPU by polling at an interval.
print("Waiting...")
GPIO.wait_for_edge(PIN_OUT, GPIO.FALLING)

#
# If we get this far, the switch has been set to OFF. Power down the system
# gracefully.
#

# Clean up GPIO just in case.
GPIO.cleanup()

# Use this stub file to keep track of the last shutdown.
os.system("touch '/home/pi/last_poweroff'")

print("Powering off!")
os.system('sudo poweroff')</code></pre>

<pre id="javascript"><code class="javascript">

let fibonacci = {
  [Symbol.iterator]() {
    let pre = 0, cur = 1;
    return {
      next () {
        [ pre, cur ] = [ cur, pre + cur ];
        return { done: false, value: cur };
      }
    };
  }
}

for (let n of fibonacci) {
    if (n > 1000)
        break;
    console.log(n);
}

const foo = Symbol.for("app.foo");
const bar = Symbol.for("app.bar");

let foo = 'bar', baz = { thud: 'troz' },
  somethingElse = [1, 2, { ['this' + 'thing']: 'is weird' }];

class Shape {
  // ...
  toString () {
    return `Shape(${this.id})`
  }
}
class Rectangle extends Shape {
  constructor (id, x, y, width, height) {
    super(id, x, y);
    // ...
  }
  toString () {
    return "Rectangle > " + super.toString();
  }

  set width (newWidth) {
    this._width = newWidth;
  }

  get width () {
    return this._width;
  }

  static defaultCircle () {
    return new Circle("default", 0, 0, 100);
  }
}
class Circle extends Shape {
  constructor (id, x, y, radius) {
    super(id, x, y);
    // ...
  }
  toString () {
    return "Circle > " + super.toString();
  }
}

0b111110111 === 503;
0o767 === 503;

// Fakeout! new Headers({ foo: 'bar' });

/*
 * Fakeout! new Headers({ foo, bar });
 * Fakeout! new Headers({ foo, bar });
 * Fakeout! new Headers({ foo, bar });
 */

let obj = { lorem: 'ipsum', dolor: /sit amet/ };

let bar = await zort();

async function zort () {
  return new Promise((resolve, reject) => {
    // ...
  });
}

let foo = `bar ${something + 1} baz thud`;

class CustomHighlighter extends Highlighter {
  foo (bar, baz) {
    let wat = (huh, wat=1) => huh + 1;
    console.log('thud');
  }
}

let { blah, zort: troz, [five, six] } = getProps();

getThing()
  .then( e => e.json() )
  .catch( e => console.log(e) );

"what"

let ternary = true ? '1' : "2";

let ternary = true ? "2" : '1';

let multiLineTernary = true ?
  doSomething() :
  doSomethingElse();

var Try = {
  these: function(one, two, three, ...rest) {
    var returnValue;

    // What is this

    for (var i = 0, length = /* ahaha */ arguments.length; i &amp;lt; length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) {
        /(foo(bar))/.test('aha', 13, 'boo');
        throw 'This isn\'t what I had in mind.';
      }
    }

    return returnValue;
  }
};</code></pre>

<pre id="html"><code class="html">&amp;lt;img src="foo.gif" width="1000" height="4" alt="Lorem ipsum dolor." /&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;Lorem ipsum dolor sit amet. width="1000" (that was a test)&amp;lt;/li&amp;gt;

  &amp;lt;script&amp;gt;var foo = 'bar';&amp;lt;/script&amp;gt;

  &amp;lt;script type="text/javascript"&amp;gt;var foo = '\\bar';&amp;lt;/script&amp;gt;

  &amp;lt;SCRIPT type="text/javascript"&amp;gt;var foo = '\\bar';&amp;lt;/script&amp;gt;

  &amp;lt;script&amp;gt;
    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) { }
    }
  &amp;lt;/script&amp;gt;

&amp;lt;/ul&amp;gt;</code></pre>

<pre id="ruby"><code class="ruby">
UH_OH = %Q{
  this { \{ #{thing + 1} will be a \} problem. }
}

class Spot &amp;lt; ActiveRecord::Base
  def to_public_json(format=:full, options={:foo => "bar", :baz => :thud, :zort => 5_000, :troz => { :wat => 'this is ridiculous' } }, nil_by_default=nil, false_by_default=false)
    hash = {
      :message    => self.message,
      :created_at => self.created_at,
      :spot       => self.spot.to_public_json(options[:spot_format] || :short),
      :user       => self.user.to_public_json(options[:user_format] || :short)
    }

    @what = ""

    # Perhaps attach other properties, depending on which format we wanted
    if format == :full
      "\\lorem\" #{ipsum + 4 + foo}\" dolor\""
      # et cetera
    end

    if format =~ /\blorem\sipsum\sdolor/
      `cat foo > bar #{bacon}`
    end

    format =~ /\b(lorem(?:\sipsum(\sdolo(r)?)))/


    foo.map { |id| "/spots/#{id}" }

    troz.map do |bar, baz|
      zort &amp;lt;&amp;lt; baz
    end

    hash
  end

  def block_stuff
    # Nested blocks.
    foo.map { |id|
      item.map { |wtf| "wtf#{id}"}
      "foo#{id}"
    }
  end

  def string_stuff
    # Should not be escaped/interpolated.
    '\\lorem\" #{ipsum + 4 + foo}\" dolor\"'

    # Should be escaped/interpolated.
    "\\lorem\" #{ipsum + 4 + foo}\" dolor\""
  end

  def number_stuff
    # Should be highlighted.
    val  = 1_000_000
    val  = 1_000_000.floor
    val  = 2.43
    troz = 0b1001010101
    troz = 0b100_101_0101

    nope = 1000_00_ # Should not be highlighted at all.
    nope = 1000.    # Period should not be highlighted.
  end

  def symbol_stuff
    weird_quoted_symbol = :'foobar'
    weird_quoted_symbol = :"foobar"

    # Should not be interpolated/escaped.
    wqs = :'foo\n#{bar}'

    # Should be interpolated/escaped.
    wqs = :"foo\n#{bar}"
  end

  def foo
    "bar"
  end

  @heredoc = &amp;lt;&amp;lt;-WTF
  Lorem ipsum dolor sit amet, consectetur adipisicing elit,\n sed do eiusmod tempor, #{other_latin} magna aliqua.
  WTF

end

HASH = {
  :foo => { :bar => 'baz', :thud => 'troz' },
  :zort => lambda { |x| { :baz => "{ #{something}-tr}oz" } }
}

module Foo
  attr_accessor :wtf
  attr_reader :ftw
  attr_writer :lmao
  def self.bar(troz)
    troz || 0
  end

  protected

  def zort(where=nil)
    Zort.new(where, :foo)
  end
end</code></pre>

<pre><code class="ruby"># Make string suitable for display as HTML, preserve spaces. Set :no_newline_after_br => true
# to cause “\n” to be substituted by “&amp;lt;br&amp;gt;” instead of “&amp;lt;br&amp;gt;\n”
def htmlize(str, opts = {})
  str = str.to_s.gsub("&amp;", "&amp;amp;").gsub("&amp;lt;", "&amp;lt;")
  str = str.gsub(/\t+/, '&amp;lt;span style=&amp;quot;white-space:pre;&amp;quot;&amp;gt;\0&amp;lt;/span&amp;gt;')
  str = str.gsub(/(^ +)|( )( +)/) { "#$2#{'&amp;nbsp;' * ($1 || $3).length}" }
  if opts[:no_newline_after_br].nil?
    str.gsub("\n", "&amp;lt;br&amp;gt;\n")
  else
    str.gsub("\n", "&amp;lt;br&amp;gt;")
  end
end</code></pre>

<pre id="nginx"><code class="nginx">server {
  listen 80;      # for IPv4
  listen [::]:80; # for IPv6

  server_name node-red.home.local;
  access_log /var/log/nginx/node-red.access.log;

  location / {
    proxy_pass http://home.local:1880;

    proxy_set_header Host            $host;
    proxy_set_header X-Real-IP       $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_http_version 1.1;

    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_cache_bypass 1;
    proxy_no_cache 1;

    port_in_redirect on;
  }
}</code></pre>

<script type="text/javascript">
  Support.setup();
</script>

</body>
</html>
